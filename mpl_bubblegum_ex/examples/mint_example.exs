# Example: Minting a compressed NFT and submitting it to Solana Devnet

alias MplBubblegum.Types.{Pubkey, Creator, Metadata}

# Load payer keypair from file (generated by solana-keygen)
payer_json = Jason.decode!(File.read!("payer.json"))
payer_secret = Base.decode64!(payer_json["secret"])
{:ok, payer} = Pubkey.from_base58(payer_json["public"])

# Load tree creator keypair from file (generated by solana-keygen)
tree_creator_json = Jason.decode!(File.read!("tree_creator.json"))
{:ok, tree_creator} = Pubkey.from_base58(tree_creator_json["public"])

# Load tree config keypair from file (generated by solana-keygen)
tree_config_json = Jason.decode!(File.read!("tree_config.json"))
{:ok, tree_config} = Pubkey.from_base58(tree_config_json["public"])

# Load merkle tree keypair from file (generated by solana-keygen)
merkle_tree_json = Jason.decode!(File.read!("merkle_tree.json"))
{:ok, merkle_tree} = Pubkey.from_base58(merkle_tree_json["public"])

# Use payer as the owner for simplicity
{:ok, owner} = Pubkey.from_base58(payer_json["public"])

# Define metadata
creator = %Creator{address: payer, verified: true, share: 100}
metadata = %Metadata{
  name: "My Compressed NFT",
  symbol: "CNFT",
  uri: "https://example.com/metadata.json",
  seller_fee_basis_points: 500,
  primary_sale_happened: false,
  is_mutable: true,
  edition_nonce: nil,
  token_standard: Metadata.non_fungible(),
  collection: nil,
  uses: nil,
  token_program_version: Metadata.original(),
  creators: [creator]
}

# Mint transaction
params = %{
  tree_config: tree_config,
  leaf_owner: owner,
  leaf_delegate: owner,
  merkle_tree: merkle_tree,
  payer: payer,
  tree_creator_or_delegate: tree_creator,
  metadata: metadata
}

IO.puts("Minting NFT with pubkeys:")
IO.puts("- Payer/Owner: #{payer_json["public"]}")
IO.puts("- Tree Creator: #{tree_creator_json["public"]}")
IO.puts("- Tree Config: #{tree_config_json["public"]}")
IO.puts("- Merkle Tree: #{merkle_tree_json["public"]}")

case MplBubblegum.mint_v1(params) do
  {:ok, transaction} ->
    IO.puts("Transaction created (size: #{byte_size(transaction)} bytes). Signing and submitting...")
    case MplBubblegum.sign_and_submit_transaction(transaction, payer_secret) do
      {:ok, signature} ->
        IO.puts("Transaction submitted with signature: #{signature}")
        check_status(signature)

      {:error, reason} ->
        IO.puts("Failed to submit transaction: #{reason}")
    end

  {:error, reason} ->
    IO.puts("Failed to create transaction: #{reason}")
end

defp check_status(signature) do
  Process.sleep(2000)
  case MplBubblegum.get_transaction_status(signature) do
    {:ok, "confirmed"} -> IO.puts("Transaction confirmed!")
    {:ok, status} -> IO.puts("Transaction status: #{status}")
    {:error, reason} -> IO.puts("Failed to check status: #{reason}")
  end
end